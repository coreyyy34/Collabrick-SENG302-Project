package nz.ac.canterbury.seng302.homehelper.controller.auth;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import nz.ac.canterbury.seng302.homehelper.entity.user.User;
import nz.ac.canterbury.seng302.homehelper.exceptions.auth.UserDetailsInvalidException;
import nz.ac.canterbury.seng302.homehelper.exceptions.user.UserNotActivatedException;
import nz.ac.canterbury.seng302.homehelper.service.user.UserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class LoginController {

    private final Logger logger = LoggerFactory.getLogger(LoginController.class);
    private final UserService userService;

    @Autowired
    public LoginController(UserService userService) {
        this.userService = userService;
    }

    /**
     * GETs initial login page
     *
     * @return Login page
     */
    @GetMapping("/login")
    public String loginPage(
            @RequestParam(value = "redirect", required = false) String redirectUrl,
            Model model,
            HttpServletRequest request) {
        logger.info("GET /login");

        // redirect the user to home if they are already logged in
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.isAuthenticated() && !auth.getPrincipal().equals("anonymousUser")) {
            return "redirect:" + (validateRedirect(redirectUrl) ? redirectUrl : "/");
        }

        model.addAttribute("user", new User());
        model.addAttribute("activeLink", "login");
        model.addAttribute("redirectUrl", redirectUrl);
        return "pages/auth/loginPage";
    }

    /**
     * Controller to log a user out
     *
     * @param request the request sent to the server
     * @return a redirect to the login page
     */
    @GetMapping("/logout")
    public String logoutPage(HttpServletRequest request) {
        try {
            request.logout();
            request.getSession().invalidate();
        } catch (ServletException e) {
            throw new RuntimeException(e);
        }
        return "redirect:/";
    }

    /**
     * Log in and authenticate the user OR reject login if credentials are invalid
     *
     * @param user    User object
     * @param model   Model
     * @param request HTTP request object
     * @return Either remain on login page or redirect to main page
     */
    @PostMapping("/do_login")
    public String submitLogin(
            @ModelAttribute User user,
            @RequestParam(value = "redirect", required = false) String redirectUrl,
            Model model,
            HttpServletRequest request) {
        logger.info("POST /do_login - Email: {}", user.getEmail());
        try {
            userService.validateUserForSignIn(user);
            request.login(user.getEmail(), user.getPassword());

            if (validateRedirect(redirectUrl)) {
                return "redirect:" + redirectUrl;
            }
        } catch (UserNotActivatedException e) {
            return "redirect:/verification";
        } catch (UserDetailsInvalidException e) {
            model.addAttribute("errors", e);
            return "pages/auth/loginPage";
        } catch (ServletException e) {
            // should not happen due to having our own authentication provider
            logger.error("Encountered unexpected authentication exception", e);
            return "pages/auth/loginPage";
        }
        return "redirect:/";
    }

    // generated by chatgpt
    private boolean validateRedirect(String url) {
        if (url == null || url.isBlank()) {
            return false;
        }
        // Only allow relative URLs (no scheme or host)
        return url.startsWith("/") && !url.startsWith("//") && !url.contains("\n") && !url.contains("\r");
    }
}
