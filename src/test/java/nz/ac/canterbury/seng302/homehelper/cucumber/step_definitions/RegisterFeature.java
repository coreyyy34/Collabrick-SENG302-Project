package nz.ac.canterbury.seng302.homehelper.cucumber.step_definitions;

import io.cucumber.java.Before;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import jakarta.transaction.Transactional;
import nz.ac.canterbury.seng302.homehelper.entity.user.User;
import nz.ac.canterbury.seng302.homehelper.exceptions.auth.UserDetailsInvalidException;
import nz.ac.canterbury.seng302.homehelper.repository.user.UserRepository;
import nz.ac.canterbury.seng302.homehelper.service.user.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.ui.ModelMap;

import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import static java.util.Objects.requireNonNull;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

@Transactional
@SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
public class RegisterFeature {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserService userService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    private MvcResult result;
    private Map<String, String> formData;
    private long userCountBefore;

    @Before
    public void setup() {
        formData = new HashMap<>();
    }

    @Given("I want to register and I am on the system's main URL")
    public void i_want_to_register_and_i_am_on_the_system_s_main_url() throws Exception {
        result = mockMvc.perform(get("/"))
                .andExpect(status().isOk())
                .andExpect(view().name("pages/homePage"))
                .andReturn();
    }

    @Given("a user exists with first name {string}, last name {string}, email {string}, password {string}, retype password {string}")
    public void a_user_exists_with_first_name_last_name_email_password_retype_password(String firstName, String lastName, String email, String password, String retypePassword) {
        // encode passwords since we're adding them straight via the repository to bypass activation
        password = passwordEncoder.encode(password);
        retypePassword = passwordEncoder.encode(retypePassword);
        User user = new User(firstName, lastName, email, password, retypePassword);
        user.setActivated(true);
        userRepository.save(user);
    }

    @Given("I am on the registration form")
    public void i_am_on_the_registration_form() throws Exception {
        mockMvc.perform(get("/register"))
                .andExpect(status().isOk())
                .andExpect(view().name("pages/auth/registerPage"));
    }

    @When("I enter {string} as the {string} on the registration form")
    public void i_enter_as_the_on_the_registration_form(String value, String fieldName) {
        formData.put(fieldToParamName(fieldName), value);
    }

    @When("I click the Sign Up button on the registration form")
    public void i_click_the_sign_up_button_on_the_registration_form() throws Exception {
        userCountBefore = userRepository.count();
        result = mockMvc.perform(post("/register")
                        .param("fname", formData.getOrDefault("fname", ""))
                        .param("lname", formData.getOrDefault("lname", ""))
                        .param("email", formData.getOrDefault("email", ""))
                        .param("password", formData.getOrDefault("password", ""))
                        .param("retypePassword", formData.getOrDefault("retypePassword", ""))
                        .with(csrf()))
                .andReturn();
    }

    @Then("I see a button labelled Register to view the register form")
    public void i_see_a_button_labelled_register_to_view_the_register_form() throws UnsupportedEncodingException {
        String content = result.getResponse().getContentAsString();
        // pattern generated by ChatGPT to find an anchor with specific text not caring about spaces or attributes other than href
        // Regex to find: <a ... href="/register" ...>Register</a>
        Pattern pattern = Pattern.compile(
                "<a[^>]*href=[\"']/register[\"'][^>]*>\\s*Register\\s*</a>",
                Pattern.CASE_INSENSITIVE
        );
        assertTrue(pattern.matcher(content).find());
    }

    @Then("I should see an error message for the field {string} {string} on the registration form")
    public void i_should_see_an_error_message_for_the_field_on_the_registration_form(String fieldName, String errorMessage) {
        ModelMap model = requireNonNull(result.getModelAndView()).getModelMap();
        UserDetailsInvalidException exception = (UserDetailsInvalidException) requireNonNull(model.getAttribute("errors"));
        assertEquals(errorMessage, extractErrorMessage(exception, fieldName));
    }

    @Then("no account should be created")
    public void no_account_should_be_created() {
        long userCountAfter = userRepository.count();
        assertEquals(userCountBefore, userCountAfter, "A new user was unexpectedly created.");
    }

    private String fieldToParamName(String field) {
        return switch (field) {
            case "first name" -> "fname";
            case "last name" -> "lname";
            case "email" -> "email";
            case "password" -> "password";
            case "retype password" -> "passwordRetype";
            default -> throw new IllegalArgumentException("Param - Unknown field: " + field);
        };
    }

    private String extractErrorMessage(UserDetailsInvalidException exception, String field) {
        return switch (field) {
            case "first name" -> exception.getFirstNameError();
            case "last name" -> exception.getLastNameError();
            case "email" -> exception.getEmailError();
            case "password" -> exception.getPasswordError();
            default -> throw new IllegalArgumentException("Error param - Unknown field: " + field);
        };
    }
}
