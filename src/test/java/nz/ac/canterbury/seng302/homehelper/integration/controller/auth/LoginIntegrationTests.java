package nz.ac.canterbury.seng302.homehelper.integration.controller.auth;

import jakarta.transaction.Transactional;
import nz.ac.canterbury.seng302.homehelper.entity.user.User;
import nz.ac.canterbury.seng302.homehelper.repository.user.UserRepository;
import nz.ac.canterbury.seng302.homehelper.validation.user.UserValidation;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.hamcrest.Matchers.hasProperty;
import static org.hamcrest.Matchers.is;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

// Source values generated by ChatGPT
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
public class LoginIntegrationTests {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    private User testUser;
    private String testUserPassword;

    @BeforeEach
    public void setup() {
        testUserPassword = "Secure_Pass2";
        String encryptedPassword = passwordEncoder.encode(testUserPassword);
        testUser = new User("Jane", "Smith", "jane.smith@example.com", encryptedPassword, encryptedPassword);
        testUser.setActivated(true);
        userRepository.save(testUser);
    }

    /* GET /login */
    @Test
    void testLoginPage_WhenAccessedByAnonymousUser_ThenShowsLoginView() throws Exception {
        mockMvc.perform(get("/login"))
                .andExpect(status().isOk())
                .andExpect(view().name("pages/auth/loginPage"));
    }

    @Test
    @WithMockUser(username = "1")
    void testLoginPage_WhenAccessedByAuthenticatedUser_ThenRedirectsToHome() throws Exception {
        mockMvc.perform(get("/login"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));
    }

    /* POST /login */
    @ParameterizedTest
    @ValueSource(strings = {
            "",
            "    ",
            "invalid-email",
            "invalid@email",
            "invalid@email.",
            "@invalid.com",
            "invalid@.com",
            "invalid@email..com"
    })
    void testSubmitLoginForm_WhenEmailIsInvalid_ThenShowLoginWithError(String input) throws Exception {
        mockMvc.perform(post("/do_login")
                        .with(csrf())
                        .param("email", input))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("emailError", is(UserValidation.EMAIL_INVALID_FORMAT))));
    }

    @Test
    void testSubmitLoginForm_WhenEmailIsNotInUse_ThenShowLoginWithError() throws Exception {
        mockMvc.perform(post("/do_login")
                        .with(csrf())
                        .param("email", "ben.smith@example.com")
                        .param("password", "Strong$Pass1"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("credentialsError", is(UserValidation.EMAIL_UNKNOWN_OR_PASSWORD_INVALID))));
    }

    @Test
    void testSubmitLoginForm_WhenEmailInUseAndPasswordIsWrong_ThenShowLoginWithError() throws Exception {
        mockMvc.perform(post("/do_login")
                        .with(csrf())
                        .param("email", testUser.getEmail())
                        .param("password", "Cool-Pass5"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("credentialsError", is(UserValidation.EMAIL_UNKNOWN_OR_PASSWORD_INVALID))));
    }

    @Test
    void testSubmitLoginForm_WhenEmailInUseAndPasswordIsCorrectAndUserIsNotVerified_ThenRedirectToVerificationPage() throws Exception {
        testUser.setActivated(false);
        userRepository.save(testUser);
        mockMvc.perform(post("/do_login")
                        .with(csrf())
                        .param("email", testUser.getEmail())
                        .param("password", testUserPassword))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/verification"));
    }

    @Test
    void testSubmitLoginForm_WhenEmailInUseAndPasswordIsCorrectAndUserIsVerified_ThenLoginAndRedirectToUserPage() throws Exception {
        mockMvc.perform(post("/do_login")
                        .with(csrf())
                        .param("email", testUser.getEmail())
                        .param("password", testUserPassword))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));
    }
}
