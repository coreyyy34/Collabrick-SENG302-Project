package nz.ac.canterbury.seng302.homehelper.integration.controller.auth;

import jakarta.transaction.Transactional;
import nz.ac.canterbury.seng302.homehelper.entity.user.User;
import nz.ac.canterbury.seng302.homehelper.entity.user.VerificationToken;
import nz.ac.canterbury.seng302.homehelper.repository.auth.VerificationTokenRepository;
import nz.ac.canterbury.seng302.homehelper.repository.user.UserRepository;
import nz.ac.canterbury.seng302.homehelper.service.EmailService;
import nz.ac.canterbury.seng302.homehelper.service.user.UserService;
import nz.ac.canterbury.seng302.homehelper.validation.user.UserValidation;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.test.mock.mockito.SpyBean;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Optional;
import java.util.stream.Stream;

import static org.hamcrest.Matchers.hasProperty;
import static org.hamcrest.Matchers.is;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

// Source values generated by ChatGPT
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
public class RegisterIntegrationTests {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserService userService;

    @SpyBean
    private UserRepository userRepository;

    @SpyBean
    private VerificationTokenRepository verificationTokenRepository;

    @MockBean // prevent the email actually sending
    private EmailService emailService;

    static Stream<String> invalidNames() {
        return Stream.of(
                "John123",
                "John@Doe",
                "John@Doe!",
                "John#Doe",
                "John_Doe",
                "John!Doe",
                "-",
                "'",
                "--",
                "''",
                "-'-",
                "ðŸ˜Š",
                "AnnaðŸ˜Š"
        );
    }

    static Stream<String> invalidNamesEmpty() {
        return Stream.of("", "   ", "\t", "\n");
    }

    /* GET /register */
    @Test
    void testRegisterPage_WhenAccessedByAnonymousUser_ThenShowsRegisterView() throws Exception {
        mockMvc.perform(get("/register"))
                .andExpect(status().isOk())
                .andExpect(view().name("pages/auth/registerPage"));
    }

    @Test
    @WithMockUser(username = "1")
    void testRegisterPage_WhenAccessedByAuthenticatedUser_ThenRedirectsToHome() throws Exception {
        mockMvc.perform(get("/register"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));
    }

    /* POST /register */
    @ParameterizedTest
    @CsvSource({
            "John, Doe, john.doe@example.com, Strong$Pass1, Strong$Pass1",
            "Alice, Smith, alice.smith@example.com, Secure_Pass2, Secure_Pass2",
            "Bob, Jones, bob.jones@example.com, Another-Pass3, Another-Pass3",
            "Charlie, Brown, charlie.brown@example.com, Valid.Pass4, Valid.Pass4"
    })
    void testSubmitRegisterForm_WhenValidValuesProvided_ThenUserIsCreatedAndRedirectsToVerification(
            String firstName, String lastName, String email, String password, String confirmPassword
    ) throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", firstName)
                        .param("lname", lastName)
                        .param("email", email)
                        .param("password", password)
                        .param("retypePassword", confirmPassword))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/verification"));

        // check to see if user was saved
        verify(userRepository).save(any(User.class));
        User user = userService.findUserByEmail(email);
        assertEquals(firstName, user.getFname());
        assertEquals(lastName, user.getLname());
        assertEquals(email, user.getEmail());

        // check to see if token was created for user
        verify(verificationTokenRepository).save(any());
        Optional<VerificationToken> optionalVerificationToken = verificationTokenRepository.findByUser(user);
        assertTrue(optionalVerificationToken.isPresent());

        // check to see if the verification email send method is called
        verify(emailService).sendRegistrationVerificationMail(eq(user), eq(optionalVerificationToken.get()));
    }

    @ParameterizedTest
    @MethodSource("invalidNames")
    void testSubmitRegisterForm_WhenFirstNameIsInvalid_ThenShowRegisterWithError(String input) throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", input)
                        .param("lname", "Doe")
                        .param("email", "test@test.com")
                        .param("password", "Abc123!!")
                        .param("retypePassword", "Abc123!!"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("firstNameError", is("First" + UserValidation.NAME_INVALID_CHARACTERS))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @ParameterizedTest
    @MethodSource("invalidNamesEmpty")
    void testSubmitRegisterForm_WhenFirstNameIsEmpty_ThenShowRegisterWithError(String input) throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", input)
                        .param("lname", "Doe")
                        .param("email", "test@test.com")
                        .param("password", "Abc123!!")
                        .param("retypePassword", "Abc123!!"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("firstNameError", is("First" + UserValidation.NAME_EMPTY))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @ParameterizedTest
    @MethodSource("invalidNames")
    void testSubmitRegisterForm_WhenLastNameIsInvalid_ThenShowRegisterWithError(String input) throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "John")
                        .param("lname", input)
                        .param("email", "test@test.com")
                        .param("password", "Abc123!!")
                        .param("retypePassword", "Abc123!!"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("lastNameError", is("Last" + UserValidation.NAME_INVALID_CHARACTERS))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @ParameterizedTest
    @ValueSource(strings = {
            "",
            "    ",
            "invalid-email",
            "invalid@email",
            "invalid@email.",
            "@invalid.com",
            "invalid@.com",
            "invalid@email..com"
    })
    void testSubmitRegisterForm_WhenEmailIsInvalid_ThenShowRegisterWithError(String input) throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "John")
                        .param("lname", "Doe")
                        .param("email", input)
                        .param("password", "Abc123!!")
                        .param("retypePassword", "Abc123!!"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("emailError", is(UserValidation.EMAIL_INVALID_FORMAT))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @Test
    void testSubmitRegisterForm_WhenEmailIsAlreadyUsed_ThenShowsRegisterWithError() throws Exception {
        User user = userRepository.save(new User("John", "Doe", "test@test.com", "password", "password"));
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "John")
                        .param("lname", "Doe")
                        .param("email", user.getEmail())
                        .param("password", "Abc123!!")
                        .param("retypePassword", "Abc123!!"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("emailError", is(UserValidation.EMAIL_IN_USE))));
        verify(userRepository, times(1)).save(any()); // only once for the test user
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @ParameterizedTest
    @ValueSource(strings = {
            "",
            "    ",
            "Short1!",
            "lowercase123!",
            "UPPERCASE123!",
            "NoNumberPass!",
            "NoSpecialChar123",
    })
    void testSubmitRegisterForm_WhenPasswordIsInvalid_ThenShowsRegisterWithError(String input) throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "John")
                        .param("lname", "Doe")
                        .param("email", "test@test.com")
                        .param("password", input))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("passwordError", is(UserValidation.PASSWORD_LOW_STRENGTH))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @Test
    void testSubmitRegisterForm_WhenConfirmedPasswordDoesNotMatchPassword_ThenShowsRegisterWithError() throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "John")
                        .param("lname", "Doe")
                        .param("email", "test@test.com")
                        .param("password", "Abc123!!")
                        .param("retypePassword", "!!321cbA"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("passwordError", is(UserValidation.PASSWORD_RETYPE_NO_MATCH))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @Test
    void testSubmitRegisterForm_WhenThereAreMultipleErrors_ThenShowRegisterWithErrors1() throws Exception {
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "")
                        .param("lname", "Doe<3")
                        .param("email", "test@test.")
                        .param("password", "Abc123!!")
                        .param("retypePassword", "!!321cbA"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("firstNameError", is("First" + UserValidation.NAME_EMPTY))))
                .andExpect(model().attribute("errors",
                        hasProperty("lastNameError", is("Last" + UserValidation.NAME_INVALID_CHARACTERS))))
                .andExpect(model().attribute("errors",
                        hasProperty("emailError", is(UserValidation.EMAIL_INVALID_FORMAT))))
                .andExpect(model().attribute("errors",
                        hasProperty("passwordError", is(UserValidation.PASSWORD_RETYPE_NO_MATCH))));
        verify(userRepository, never()).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }

    @Test
    void testSubmitRegisterForm_WhenThereAreMultipleErrors_ThenShowRegisterWithErrors2() throws Exception {
        User user = userRepository.save(new User("John", "Doe", "test@test.com", "password", "password"));
        mockMvc.perform(post("/register")
                        .with(csrf())
                        .param("fname", "Jane@")
                        .param("lname", "ThisIsAReallyReallyLongNameThatExceedsSixtyFourCharactersForTesting")
                        .param("email", "test@test.com")
                        .param("password", "Abc1")
                        .param("retypePassword", "!!321cbA"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("errors",
                        hasProperty("firstNameError", is("First" + UserValidation.NAME_INVALID_CHARACTERS))))
                .andExpect(model().attribute("errors",
                        hasProperty("lastNameError", is("Last" + UserValidation.NAME_TOO_LONG))))
                .andExpect(model().attribute("errors",
                        hasProperty("emailError", is(UserValidation.EMAIL_IN_USE))))
                .andExpect(model().attribute("errors",
                        hasProperty("passwordError", is(UserValidation.PASSWORD_LOW_STRENGTH))));
        verify(userRepository, times(1)).save(any());
        verify(verificationTokenRepository, never()).save(any());
        verify(emailService, never()).sendRegistrationVerificationMail(any(), any());
    }
}
